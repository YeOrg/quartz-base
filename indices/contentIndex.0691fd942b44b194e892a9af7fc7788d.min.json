{"/":{"title":"🪴 Quartz 3.3","content":"\nPeople's knowledge should be based on graph.","lastmodified":"2023-08-03T04:26:56.735063886Z","tags":[]},"/notes/showcase":{"title":"Showcase","content":"","lastmodified":"2023-08-03T04:26:56.735063886Z","tags":[]},"/notes/troubleshooting":{"title":"Troubleshooting and FAQ","content":"\n","lastmodified":"2023-08-03T04:26:56.735063886Z","tags":[]},"/tutorial/Graphics-Basis":{"title":"Graphics-Basis","content":"# Contents\n\n## Math Basis\n\n\u003e 内容: 方程与行列式、方程与坐标轴、坐标基矢与变换、变换复合、转置、对偶矢量、余弦定理、点乘、叉乘、线性变换(缩放、非均匀缩放、反射、错切、旋转)、平移与齐次坐标、重心坐标\n\n* **词汇表Glossary**\n  * determinant 行列式\n  * equation 方程\n  * coefficient matrix 系数矩阵\n  * area 面积\n  * coordinate axis 坐标轴\n  * polar coordinate system 极坐标系\n  * coordinate basis vector 坐标基矢\n  * transformation 变换\n  * scale 缩放\n  * Non-Uniform scale 非均匀缩放\n  * reflection 反射\n  * shear 错切\n  * vector 向量\n  * rotate 旋转\n  * translation 平移\n  * homogenous coordinates 齐次坐标\n  * coordinate component 坐标分量\n  * complex transformation 复合变换\n  * transpose 转置\n  * projection 投影\n  * dot product 点乘\n  * cross product 叉乘\n  * dual vector 对偶矢量\n  * linear transformation 线性变换\n  * affine transformation 仿射变换\n  * interpolation 插值\n  * barycentric coordinates 重心坐标\n\n* **方程与行列式**\n\n有一个方程，我们试着解一下$$\\begin{array}{l} \\left \\{ \\begin{matrix}  5x+6y=7 \\ \\ (1) \\\\ 9x+4y=3 \\ \\ (2) \\end{matrix} \\right. \\end{array}$$我们用消去法$$\\begin{array}{l} (2) \\times \\frac{5}{9} - (1) \\\\ (1)\\times \\frac{4}{6} - (2) \\end{array}$$最终可以得到$$\\begin{array}{l} y(5\\times 4-6\\times 9)=3\\times 5-7\\times 9 \\\\ x(5\\times 4-6\\times 9)=7\\times 4-6\\times 3 \\end{array}$$\n\n大家有没有注意到$x$和$y$后面的$$(5\\times 4-6\\times 9)$$他们是一样的，所以为了简化计算，我们将这个$(5\\times 4-6\\times 9)$拿出来排列成$$\\left ( \\begin{matrix} 5 \u0026 6 \\\\ 9 \u0026 4 \\end{matrix} \\right ) $$这样一组数,再定义$$\\left ( \\begin{matrix} 5 \u0026 6 \\\\ 9 \u0026 4 \\end{matrix} \\right ) = 5\\times 4 - 6\\times 9$$叫做**行列式**, 而$\\left ( \\begin{matrix} 5 \u0026 6 \\\\ 9 \u0026 4 \\end{matrix} \\right ) $也是方程中的系数(称作**系数矩阵**)，通用格式就是$$\\left ( \\begin{matrix} a\u0026b \\\\ c\u0026d \\end{matrix} \\right ) = ad-bc$$\n\n---\n\n再看另外一个方程$$\\left \\{ \\begin{matrix}  1x+0y=0 \\\\ 0x+1y=0 \\end{matrix} \\right.$$ 列出系数矩阵形式$$\\left ( \\begin{matrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{matrix} \\right )$$\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/手绘二维坐标系.qt5rv7k809s.webp\" width=\"490\"\u003e\u003c/div\u003e\n\n观察图中我们看到如果我们把$(1,0)$和$(0,1)$\"围起来\"，我们会得到一个正方形，在应用我们刚刚学的的行列式的计算方法，我们正好得到一个数字$1\\times 1-0\\times 0=1$，(同样的$2\\times 2-0\\times 0=4$，面积为4)，如果我们抛开坐标系不谈论，就单纯的把围成的区域看做是一个正方形，它的面积正好为1，不是吗？那是不是我们可以把**行列式与面积联系起来**呢？答案是：可以，我们再来看另外一个例子，我们现在讨论的是(1,0)和(0,1)下围成的区域，它正好是一个正方形，那么其它的情况呢？\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/行列式的一般情形.7gtqx3nj4x80.webp\" width=\"790\"\u003e\u003c/div\u003e\n\n我们两个坐标$(a,c)$和$(b,d)$系数矩阵为$\\left ( \\begin{matrix}  a \u0026 b \\\\ c \u0026 d \\end{matrix} \\right )$,现在形成的面积是一个平行四边形，经过计算后我们发现也满足。\n\n* **方程与坐标轴**\n\n我们从方程出发，知道了行列式这么一个家伙，下面再来看看方程是什么，方程中的**等号**是问题的核心\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/手绘一维坐标轴.2fvv0l7brt7o.webp\" width=\"590\"\u003e\u003c/div\u003e\n\n我们先定义**坐标轴**这个家伙，首先定义一条直直的线，然后我们再在这条线上定义一些单位，也就是**刻度**(1,2,3...)等，这些都是我们定义的，刻度$1$可以代表任何事物，例如一个苹果，移动了一米等等都可以，而这条直线呢，也是我们定义的，就像我们走路都是直直的前往某个地方，所以为了刻画这种东西，所以我们定义坐标轴也为直的，如果我们每个人都走路是沿曲折的曲线前进，那么我们的坐标轴估计也就是弯弯曲曲的了 (只是猜测)，好了，我们定义完了\"坐标轴\"，来看一个例子\n\n首先让我们来思考个问题，先假设$(0,)$到$(1,)$之间表示$1$米，假设小红站在$(0,)$点不动，小明从$(0,)$出发走到了$(2,)$这个位置，走了$2$米，请问，小红需要走多少个$1$米就可以达到小明现在的位置，我们假设需要走$x$个$1$米就可以达到小明的位置，表现为方程就是$1x=2,x=2$,小红需要走$2$个$1$米这么长的距离才可以达到小明的位置，这就是**方程**，描述两个事物之间的相等关系，其中等号是核心，只不过在一维情况下，比较简单，到了二维时，就要稍微复杂那么一丢丢了\n\n---\n\n这里举一个简单的二维情况下，我们还是以小明和小红走路这个例子为例，前面是在数轴上，他们可以活动的范围太小了，只在一条线上，我们现在把它扩大到一个平面上，现在取两条数轴，还有刻度，然后再让这两条数轴垂直，像$(x,y)$那样，那么能不能斜着呢？可以，只不过这些都是与我们的生活相贴近的，就像展开的地球，如果我们生活的地方就像第二张被错切之后的那样,其中的任何事物都是错切的形状，那估计我们的坐标系也就是会是那样定义了，就像$(x',y')$那样 (只是猜测)\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/手绘二维斜坐标系.51qcwl4w6hg0.webp\" width=\"590\"\u003e\u003c/div\u003e (二维坐标系，两条不相互垂直的坐标轴，就像我们所生活的世界，我们在一个巨大的平面上)\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/世界地图展开.6s0a9v3ifao0.webp\" width=\"490\"\u003e\u003c/div\u003e\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/世界地图展开-shear.5a4qowcfi4k0.webp\" width=\"490\"\u003e\u003c/div\u003e\n\n现在把这两个数轴放到一个平面中去，那么我们的维度就上升了一个层面，定义完之后，也就是说，我们不仅可以左右移动了，也可以上下移动了\n\n假设我们在$(0,0)$点，想要前往到$(2,2)$点，我们能想象得到也比较直观的就是，沿着左右方向中的右那个方向走$2$个单位，然后再沿着上下方向中的上那个方向走$2$个单位，就到了$(2,2)$，你们可能想，这也太麻烦了，我直接从$(0,0)$到$(2,2)$之间连一条线，然后沿着那条线走不就行了嘛，是的，**这就是极坐标系的由来，我们看待同一种问题的不同视角**，这里我们先讨论直角坐标系\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/二维坐标移动行程例子.6iwav4dmdck0.webp\" width=\"590\"\u003e\u003c/div\u003e\n\n回到问题，$(0,0) \\rightarrow (2,2)$, 分开来看，就是先往右移动$2m$到达$p1$，再往上移动$2m$到达$p2$，设往右移动$x$个$1m$才能到达$p1$处,然后往上移动$y$个$1m$才能到达$p2$处, 则我们有$$\\begin{array}{l} \\left \\{ \\begin{matrix} 1x=2 \\\\ 1y=2 \\end{matrix} \\right.\\\\ \\left \\{ \\begin{matrix} x=2\\\\ y=2 \\end{matrix} \\right. \\end{array}$$ 往右移动$2$个$1m$才能到达$p1$处，然后往上移动$2$个$1m$才能到达$p2$处，**这就是方程，希望到了这里，我们已经建立起了方程与行列式，方程与坐标轴，且行列式的那种表示形式，后面我们就会知道，这种表示形式就是矩阵**\n\n* **坐标基矢与变换**\n  * **坐标基矢**\n    * 坐标基矢是我们人为定义的事物；一维情形下就是数轴上$0$到$1$之间那个距离，记为$$(1,)$$二维有两个坐标轴，分别为$$(1,0)$$ 叫做$i$帽，符号记为$\\hat{i}$和$$(0,1)$$叫做$j$帽，符号记为 $\\hat{j}$ \u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/手绘坐标基.2pvxzz9z2es0.webp\" width=\"790\"\u003e\u003c/div\u003e刚才我们未引入坐标基矢，引入坐标基矢后，现在就有了一种统一的形式，上述例子的完整情况为$$\\left \\{ \\begin{matrix} 1x+0y=2 \\\\ 0x+1y=2 \\end{matrix} \\right.$$ 矩阵形式$$\\left ( \\begin{matrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{matrix} \\right ) \\left ( \\begin{matrix} x \\\\ y \\end{matrix} \\right ) = \\left ( \\begin{matrix} 2 \\\\ 2 \\end{matrix} \\right ) \\ \\ (x=2,y=2)$$\n    * 其实我们可以看到，我们想要去到的那个点$(2,2)$，本质上就是我们定义的坐标基矢(i帽和j帽)\u003cspan style=\"color:green\"\u003e\"去到了\"\u003c/span\u003e点$(2,2)$,我们把这种\u003cspan style=\"color:green\"\u003e\"去到了\"\u003c/span\u003e哪里，称为**变换**\n    * $x=2, y=2$是满足方程的一组数，也就是**坐标基矢变化的量** 这样，每当我们看到像$\\left ( \\begin{matrix} 2\\\\2 \\end{matrix} \\right )$都应想起是笛卡尔坐标系中的两个**坐标基矢的变换**, 像$\\left ( \\begin{matrix} 1\\\\1 \\end{matrix} \\right )$可以看做$$\\left ( \\begin{matrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{matrix} \\right ) \\left ( \\begin{matrix} x \\\\ y \\end{matrix} \\right ) = \\left ( \\begin{matrix} 1 \\\\ 1 \\end{matrix} \\right ) \\ \\ (x=1,y=1)$$只不过这两个坐标基没有产生任何的变化; 再如$\\left ( \\begin{matrix} 2\\\\2 \\end{matrix} \\right )$可以看做$$\\left ( \\begin{matrix} 2 \u0026 0 \\\\ 0 \u0026 2 \\end{matrix} \\right )$$ 为了便于描述，我们还通常给我们要去的$(2,2)$那个点称作**向量**，不仅有方向还有箭头，如$\\vec{a}=(2,2),\\ a_1=2, \\ a_2=2$这是在二维的情形下\n\n---\n\n* **变换复合**\n  * 变换是可以复合的考虑一组数$$\\left ( \\begin{matrix} -1 \\\\ 1 \\end{matrix} \\right ) 和 \\left ( \\begin{matrix} 2 \\\\ 2 \\end{matrix} \\right )$$其中$\\left ( \\begin{matrix} 2 \\\\ 2 \\end{matrix} \\right )$我们知道是由$\\left ( \\begin{matrix} 2 \u0026 0 \\\\ 0 \u0026 2 \\end{matrix} \\right )$变换而来，而$\\left ( \\begin{matrix} -1 \\\\ 1 \\end{matrix} \\right )$是由$\\left ( \\begin{matrix} -1 \u0026 0 \\\\ 0 \u0026 1 \\end{matrix} \\right )$变换而来，我们是可以将这两个变换组合到一起的,组合到一起最终就是$$\\left ( \\begin{matrix} -1 \u0026 0 \\\\ 0 \u0026 1 \\end{matrix} \\right )\\left ( \\begin{matrix} 2 \u0026 0 \\\\ 0 \u0026 2 \\end{matrix} \\right )$$其中变换计算的顺序是从右到左的，如果交换顺序，结果不一定相等；其中后者这个变换如之前一样，在图像上来看，就是缩放，那么前者呢？就是$i$帽从$(1,0)$变到了$(-1,0)$去，$j$帽保持不变，这种变换就像我们平常看书时翻页一样，叫做**Reflection反射**\n  * 最终结果就是从坐标基(①)开始先作用缩放(②)最后作用反射(③)\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/手绘复合变换.7kd8flleofs.webp\" width=\"790\"\u003e\u003c/div\u003e\n\n* **转置**\n  * 假设我们有一个矩阵$$A=\\left ( \\begin{matrix} 5 \u0026 6 \\\\ 9 \u0026 4 \\end{matrix} \\right )$$它表示了从$2$维到$2$维空间的变换，对应任意的$m*n$矩阵，都表示一个从 n 维空间到 m 维空间的变换，例如我们有一个$1*2$矩阵$\\left ( \\begin{matrix} 1 \u0026 -2 \\end{matrix} \\right )$，它表示了一个从2维空间到1维空间的变换，如图中我们可以看到$(1,-2)$变换到了$-1$\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/2维到1维的变换.3zimar96skc0.webp\" width=\"520\"\u003e\u003c/div\u003e可以想象成一部机器，喂入两个数，得到一个数，具体的操作过程与**投影**有关,就像一个小人在数轴上，先移动了$1$步，然后又移动了$-2$步，那么最终看来，这个小人只移动了$-1$步,即后退了一步\n  * 而转置呢，操作上来说就是*行变为列，列变成行*，转了一下，例如$$\\left ( \\begin{matrix} 1 \u0026 -2 \\end{matrix} \\right )$$转过来就是$$\\left ( \\begin{matrix} 1 \\\\ -2 \\end{matrix} \\right )$$ (即我们应当结合维度变换的角度去理解转置)\n  * 将这些操作转换成代数上就是$$\\left ( \\begin{matrix} 1 \u0026 -2 \\end{matrix} \\right ) \\cdot \\left ( \\begin{matrix} 1 \\\\ 1 \\end{matrix} \\right ) = 1\\cdot 1+ (-2\\cdot 1)=-1$$我们使用$\\cdot$这个小点来表示这种\"走了1步，又走了-2步\"这种计算，而这种计算呢，又恰巧就是我们待会要讲到的**点乘**\n  * 补充：关于更加详细的**坐标变换**， 见链接[1]-线性代数的本质\n* **对偶矢量**\n  * 给定一个**矢量**,如果存在这样一个**映射**,它把给定的矢量映射为一个实数,就说这个映射是**对偶矢量**。例如一个$n$维行向量$$(a_1,a_2\\cdots a_n)$$它既可以理解为**行向量**,也可理解为某种**映射**,该映射把给定的$n$维**列向量**$$\\left ( \\begin{matrix} b_1\\\\b_2 \\\\ \\cdots \\\\ b_n \\end{matrix}\\right )$$(矢量)映射为实数$k$, $$k=a_1b_1+a_2b_2+\\cdots+a_nb_n$$即矩阵的乘积。则这个映射满足对偶矢量的定义,因此行向量$(a_1,a_2\\cdots a_n)$是矢量$\\left ( \\begin{matrix} b_1\\\\b_2 \\\\ \\cdots \\\\ b_n \\end{matrix}\\right )$的对偶矢量。\n\n* **余弦定理**\n  * 余弦定理是描述**三角形中三边长度与一个角的余弦值关系**的数学定理，是**勾股定理在一般三角形情形下的推广**，勾股定理是余弦定理的特例\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/Law-of-Cosines.46vagpeucam0.webp\" width=\"790\"\u003e\u003c/div\u003e$$\\begin{array}{l}a^2=b^2+c^2-2bc\\ cos A \\\\ b^2=a^2+c^2-2ac\\ cos B \\\\ c^2=a^2+b^2-2ab\\ cos C \\\\ cos A = \\frac{-a^2+b^2+c^2}{2bc} \\\\ cos B = \\frac{a^2-b^2+c^2}{2ac} \\\\ cos C = \\frac{a^2+b^2-c^2}{2ab} \\\\ \\end{array}$$\n  * **延伸**\n    * 根据$$\\cos^2A+sin^2A=1$$\n    * 我们有$$\\cos A=\\frac{a^4+b^4+c^4-2a^2b^2+2b^2c^2-2a^2c^2}{4b^2c^2} $$$$ \\sin A=\\sqrt{1-\\cos^2a}=\\sqrt{\\frac{4b^2c^2}{4b^2c^2}-\\frac{a^4+b^4+c^4-2a^2b^2+2b^2c^2-2a^2c^2}{4b^2c^2}}$$$$ =\\sqrt{\\frac{4b^2c^2-(a^4+b^4+c^4-2a^2b^2+2b^2c^2-2a^2c^2)}{4b^2c^2}}$$$$ =\\frac{\\sqrt{-a^4-b^4-c^4+2b^2c^2+2c^2a^2+2a^2b^2}}{2bc}$$\n    * 三角形面积有$$\\Delta=\\frac{1}{2}bc \\sin A$$\n    * 代入$\\sin A$有$$\\Delta=\\frac{1}{4}\\sqrt{(a+b+c)(-a+b+c)(a-b+c)(a+b-c)}$$ (排列组合)\n\n* **点乘 Dot Product**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/点乘.78lv308m6p80.webp\" width=\"290\"\u003e\u003c/div\u003e\n  * 点乘我们通常用于衡量两个向量的方向差，或者衡量\"做功\"的大小，通常我们将它们单位化，然后再计算，这样取值范围就在$-1$到$1$之间，例如两个向量共向，那么值为$1$，反向则为$-1$，垂直为$0$\n  * **代数定义**\n    * 两个向量${\\displaystyle {\\vec {a}}=[a_{1},a_{2},\\cdots ,a_{n}]}$和${\\displaystyle {\\vec {b}}=[b_{1},b_{2},\\cdots ,b_{n}]}$的点积定义为$$\\begin{aligned} \\vec{a}\\cdot \\vec{b} = \\sum_{i=1}^{n} a_ib_i \\end{aligned}$$其中$n$是维度，在2维情况下就是$a_1b_1+a_2b_2$,例如$$\\left ( \\begin{matrix} 5_{(a_1)} \u0026 6_{(b_1)} \\\\ 9_{(a_2)} \u0026 4_{(b_2)} \\end{matrix} \\right )$$就是$5\\times 6+9\\times 4$ （这里需要注意与行列式的计算是不一样的，行列式是$5\\times 4-6\\times 9$）**这里点乘的计算和我们在转置那里讲到的投影是一回事**\n  * **几何定义**\n    * 在欧几里得空间中，点积可以直观地定义为$${\\displaystyle {\\vec {a}}\\cdot {\\vec {b}}=|{\\vec {a}}|\\,|{\\vec {b}}|\\cos \\theta \\;}$$其中$\\theta$为两向量之间的夹角\n  * **推导**\n    * 两个定义之间是等价的并可以互相推出\n    * 根据余弦定理则我们有$$|| a-b ||^2 = ||a||^2+||b||^2-2||a||\\ ||b||cos\\alpha$$展开得$$\\begin{aligned} \\sum^{n}_{i=1}(a_i-b_i)^2 =\\sum^{i=1}_{n}a_i^2+\\sum^{n}_{n=1}b_i^2-2||a||\\ ||b||cos\\alpha \\end{aligned}$$在二维情况下展开有$$\\begin{aligned} (a_1^2+b_1^2-2a_1b_1)+(a_2^2+b_2^2-2a_2b_2) = a_1^2+a_2^2 + b_1^2+b_2^2 - 2||a||\\ ||b||cos\\alpha \\end{aligned}$$消去所有的$a_1^2,\\ b_1^2$整理后有$$-2a_1b_1 + (-2a_2b_2) =  - 2||a||\\ ||b||cos\\alpha$$两边再同除以$-2$有$$a_1b_1 + (a_2b_2) = ||a||\\ ||b||cos\\alpha = \\vec{a}\\cdot \\vec{b}$$ 同样可以推广到$n$维 □\n  * **点乘在投影上的应用**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/DotProductForProjection.20f8sxq8tejk.webp\" width=\"390\"\u003e\u003c/div\u003e\n    * 计算出向量$\\vec{b}$在$\\vec{a}$上的投影值,则有$||\\vec{b}_{\\perp}|| = ||\\vec{b}||cos\\theta$ \n* **叉乘 Cross Product**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/叉乘.1eb9eyex849s.webp\" width=\"290\"\u003e\u003c/div\u003e\n  * 叉乘只在三维中有定义，\u003cspan style=\"color:purple\"\u003e两个向量的叉乘可以产生一个与这两个向量都垂直的新向量\u003c/span\u003e。例如计算一个物体表面的法向量\n  * **叉乘定义**$${\\displaystyle \\mathbf {a} \\times \\mathbf {b}=\\left\\|\\mathbf {a} \\right\\|\\left\\|\\mathbf {b} \\right\\|\\sin(\\theta)\\mathbf{n}}$$其中$\\theta$表示$\\mathbf{a}$向量和$\\mathbf{b}$向量之间的夹角，而 ${\\displaystyle \\mathbf {n} }$则是一个与${\\displaystyle \\mathbf {a} }$、${\\displaystyle \\mathbf {b} }$所构成的平面垂直的单位向量，方向由右手定则决定 (https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF)\n  * **模长计算**$${\\displaystyle \\left\\|\\mathbf {a} \\times \\mathbf {b} \\right\\|=\\left\\|\\mathbf {a} \\right\\|\\left\\|\\mathbf {b} \\right\\|\\sin(\\theta)}$$\n    * \u003cspan style=\"color:purple\"\u003e模长等于以两个向量为边的平行四边形的面积\u003c/span\u003e\n  * **叉乘计算**\n    * **Part1**\n      * 叉乘计算规则：如果两个向量一样，叉乘结果为$0$\n      * 通过引入单位向量，向量就可以转化成代数形式，例如$$a=a_1i+a_2j+a_3k, \\ \\ b=b_1i+b_2j+b_3k$$\n      * $i，j，k$是三个相互垂直的向量。它们刚好可以构成一个坐标系。这三个向量就是$$i=(1,0,0), \\ j=(0,1,0), \\ k=(0,0,1)$$\n    * **Part2**$$\\mathbf{a}=(a_1,a_2,a_3),\\mathbf{b}=(b_1,b_2,b_3)$$分别为两三维向量，叉乘为$$\\mathbf{a}\\times \\mathbf{b}=\\ \u003ca_2b_3-a_3b_2,\\ \\ a_3b_1-a_1b_3,\\ \\ a_1b_2-a_2b_1\u003e$$也可以写成**伪行列式**的形式$$a\\times b = \\left ( \\begin{matrix} \\mathbf{i} \u0026 \\mathbf{j} \u0026 \\mathbf{k} \\\\ a_1 \u0026 a_2 \u0026 a_3 \\\\ b_1 \u0026 b_2 \u0026 b_3 \\end{matrix} \\right ) = \\mathbf{i}(a_2b_3-a_3b_2) + \\mathbf{j}(a_3b_1-a_1b_3) + \\mathbf{k}(a_1b_2-a_2b_1)$$$$\\mathbf{a}\\times \\mathbf{b} = \\left ( \\begin{matrix} a_2b_3-a_3b_2 \\\\ a_3b_1-a_1b_3 \\\\ a_1b_2-a_2b_1 \\end{matrix} \\right )$$\n    * **Part3**\n      * 先以二维为例，假设有一个向量$\\mathbf{a}=(a_1,a_2)$然后我们引入反对称矩阵$$\\mathbf{H} = \\left ( \\begin{matrix} 0\u0026-1\\\\1\u00260 \\end{matrix}\\right )$$然后计算$$\\mathbf{a}\\mathbf{H}\\mathbf{a}^T$$得结果为$$\\left ( \\begin{matrix} a_1\u0026a_2 \\end{matrix} \\right )  \\left ( \\begin{matrix} 0\u0026-1 \\\\ 1\u00260 \\end{matrix} \\right )  \\left ( \\begin{matrix} a_1\\\\a_2 \\end{matrix} \\right ) = \\left ( \\begin{matrix} a_1\u0026a_2 \\end{matrix} \\right )  \\left ( \\begin{matrix} -a_2 \\\\a_1 \\end{matrix} \\right ) = \\left ( \\begin{matrix} a_1(-a_2) + a_2a_1 \\end{matrix} \\right ) = 0$$\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/反对称矩阵比较.190iia091ml.webp\"\u003e\u003c/div\u003e\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/反对称变换-图解.6sycqrfdsxk0.webp\"\u003e\u003c/div\u003e\n      * 由叉乘的规则我们有$$a\\times a = [a]_\\times * a = 0$$其中$[a]_\\times$表示某个叉乘矩阵，然后作用到了$a$得结果为$0$,通过对比，我们可以发现，$\\mathbf{a}\\mathbf{H}$就是向量a的叉乘矩阵，当$\\mathbf{a}$为列向量时，$\\mathbf{a}^T\\mathbf{H}$为a向量的叉乘矩阵，如果向量$\\mathbf{a} = (a_1,a_2,a_3)$为三维向量，那么H为$$\\mathbf{H} = \\left ( \\begin{matrix} H_1\\\\H_2\\\\H_3 \\end{matrix}\\right ) \\ \\mathbf{H_1} = \\left ( \\begin{matrix} 0\u00260\u00260\\\\0\u00260\u0026\\textcolor{#00FF00}{-1}\\\\0\u0026\\textcolor{#00FF00}{1}\u00260 \\end{matrix}\\right ) \\ \\mathbf{H_2} = \\left ( \\begin{matrix} 0\u00260\u0026\\textcolor{#0000FF}{1}\\\\0\u00260\u00260\\\\\\textcolor{#0000FF}{-1}\u00260\u00260 \\end{matrix}\\right ) \\ \\mathbf{H_3} = \\left ( \\begin{matrix} 0\u0026\\textcolor{#FF0000}{-1}\u00260\\\\\\textcolor{#FF0000}{1}\u00260\u00260\\\\0\u00260\u00260 \\end{matrix}\\right )$$最后将变换合并起来就是$$\\mathbf{H} = \\left ( \\begin{matrix} 0\u0026\\textcolor{#FF0000}{-1}\u0026\\textcolor{#0000FF}{1}\\\\\\textcolor{#FF0000}{1}\u00260\u0026\\textcolor{#00FF00}{-1}\\\\\\textcolor{#0000FF}{-1}\u0026\\textcolor{#00FF00}{1}\u00260 \\end{matrix}\\right )$$则最终有$$\\mathbf{a}\\mathbf{H} = \\left ( \\begin{matrix} 0\u0026\\textcolor{#FF0000}{-a_3}\u0026\\textcolor{#0000FF}{a_2}\\\\\\textcolor{#FF0000}{a_3}\u00260\u0026\\textcolor{#00FF00}{-a_1}\\\\\\textcolor{#0000FF}{-a_2}\u0026\\textcolor{#00FF00}{a_1}\u00260 \\end{matrix}\\right )$$$$\\mathbf{a}\\times \\mathbf{b} = \\mathbf{A}*\\mathbf{b} = \\left ( \\begin{matrix} 0\u0026-a_3\u0026a_2 \\\\ a_3\u00260\u0026-a_1 \\\\ -a_2\u0026a_1\u00260 \\end{matrix} \\right )\\left ( \\begin{matrix} b_1\\\\b_2\\\\b_3 \\end{matrix} \\right )$$\n    * **Part4**\n      * 根据内积和外积的定义$$(\\mathbf{a}\\times \\mathbf{b})\\cdot \\mathbf{a} =\u003ca_2b_3-a_3b_2,\\ \\ a_3b_1-a_1b_3,\\ \\ a_1b_2-a_2b_1\u003e \\cdot \\mathbf{a} \\\\ =\\ a_1(a_2b_3-a_3b_2) + a_2(a_3b_1-a_1b_3) + a_3(a_1b_2-a_2b_1) \\\\ $$ $$= \\textcolor{#FF0000}{a_1a_2b_3}-\\textcolor{orange}{a_1a_3b_2}+\\textcolor{#0000FF}{a_2a_3b_1}-\\textcolor{red}{a_2a_1b_3}+\\textcolor{orange}{a_3a_1b_2}-\\textcolor{blue}{a_3a_2b_1} = 0$$\n      * 假设有两个不共线的向量，分别为$(a_1,a_2,a_3),(b_1,b_2,b_3)$,我们设我们要找的垂直于这两个向量的向量为$(x,y,z)$，那么我们则有如下方程$$\\left ( \\begin{matrix} a_1\u0026a_2\u0026a_3\\\\b_1\u0026b_2\u0026b_3 \\end{matrix} \\right )\\left ( \\begin{matrix} x\\\\y\\\\z \\end{matrix} \\right ) = \\left ( \\begin{matrix} 0\\\\0 \\end{matrix} \\right ) =0$$ $$\\Rightarrow \\left \\{ \\begin{matrix} a_1x+a_2y+a_3z=0 \\\\ b_1x+b_2y+b_3z=0 \\end{matrix} \\right .$$ (这里可以看做向量$(a_1,a_2,a_3)$和$(b_1,b_2,b_3)$分别与要求向量$(x,y,z)$的点乘，如果垂直点乘结果为$0$) 令式子中的$z=1$,则我们有$$\\left \\{ \\begin{matrix} a_1x+a_2y=-a_3 \\ (1)\\\\b_1x+b_2y=-b_3 \\ (2) \\end{matrix}\\right .$$ (因为我们的方程组的秩小于未知数的个数，这里不妨设$z=1$然后再求解)\n      * 然后解二元一次方程，另$(1)\\times \\frac{b_1}{a_1}-(2)$得$$y=\\frac{a_1b_3-a_3b_1}{a_2b_1-a_1b_2}$$与$$x=\\frac{a_3b_2-a_2b_3}{a_2b_1-a_1b_2}$$因此所求向量为$$(\\frac{a_3b_2-a_2b_3}{a_2b_1-a_1b_2}, \\ \\frac{a_1b_3-a_3b_1}{a_2b_1-a_1b_2}, \\ 1)$$ 改变一下形式我们有$$(a_3b_2-a_2b_3, \\ a_1b_3-a_3b_1, \\ a_2b_1-a_1b_2)$$这个形式与之前的形式相差了一个$-$号，还有另外一种解法使用$(2)\\times \\frac{a_1}{b_1} - (1)$所得的结果的形式与之前的形式相同\n  * 补充(https://github.com/Krasjet/quaternion/blob/master/quaternion.pdf)\n    * 叉乘的定义在历史顺序上来说是从Graßmann积中导出\n\n* **线性变换Linear Transforms**\n  * **缩放Scale**$$\\left ( \\begin{matrix} x'\\\\ y' \\end{matrix} \\right ) = \\left ( \\begin{matrix} s\u00260\\\\ 0\u0026s \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y \\end{matrix} \\right )$$\n\n[UniformScale](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/UniformScale.mp4 ':include :type=video controls width=100% height=360px')\n\n  * **非均匀缩放 Scale (Non-Uniform)**$$\\left ( \\begin{matrix} x'\\\\ y' \\end{matrix} \\right ) = \\left ( \\begin{matrix} s_1\u00260\\\\ 0\u0026s_2 \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y \\end{matrix} \\right )$$\n\n[NonUniformScale](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/NonUniformScale.mp4 ':include :type=video controls width=100% height=360px')\n\n  * **反射Reflection**$$\\left ( \\begin{matrix} x'\\\\ y' \\end{matrix} \\right ) = \\left ( \\begin{matrix} -1\u00260\\\\ 0\u00261 \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y \\end{matrix} \\right )$$\n\n[Reflection](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/Reflection.mp4 ':include :type=video controls width=100% height=360px')\n\n  * **错切Shear**$$\\left ( \\begin{matrix} x'\\\\ y' \\end{matrix} \\right ) = \\left ( \\begin{matrix} 1\u0026a\\\\ 0\u00261 \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y \\end{matrix} \\right )$$\n\n[ShearMatrix](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/ShearMatrix.mp4 ':include :type=video controls width=100% height=360px')\n\n[Shear](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/Shear.mp4 ':include :type=video controls width=100% height=360px')\n\n  * **旋转Rotate**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/手绘-Rotate.3lljascgw0k0.webp\" width=\"790\"\u003e\u003c/div\u003e \n    $$\\mathbf{R}_\\theta = \\left ( \\begin{matrix} \\textcolor{#ddeeff}{cos\\theta} \u0026 \\textcolor{black}{-sin\\theta} \\\\  \\textcolor{#ddeeff}{sin\\theta} \u0026 \\textcolor{black}{cos\\theta} \\end{matrix} \\right )$$\n\n[Rotation](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/Rotation.mp4 ':include :type=video controls width=100% height=360px')\n\n* **平移Translation与齐次坐标Homogenous Coordinates**\n  * **平移**\n    * 平移不是一个线性变换，它是一个**仿射变换**，因为线性变换其中的一个特性就是变换前后坐标系的原点保持不变，显然平移不满足这个特性；或者还可以说我们无法用一个矩阵去描述这个变换，不像之前的旋转缩放等变换我们都可以用一个矩阵就可以描述。再从另外一个角度来描述就是我们\"无法通过只使用乘法来描述这个变换\"\n    * 我们假设一个场景，在一维情景下，我们有一个数轴，还有三个点在$$a=1,\\ b=2,\\ c=3$$处，我们想要将这三个点往右移动一个单位,也就是$$a'=a+1;\\ b'=b+1,\\ c'=c+1$$这是对这三个点都使用\"+1\"这个一个同样的操作我们做到了，那么我们可不可以使用乘法呢？我们观察到，$a'=2,\\ a=1$，要想使用乘法就需要乘以$2$，因为之间相差$2$倍，也就是$a'=2a$,但是对于另外两个点，$2b$和$2c$则不是我们想要的结果，问题我们是否可以找到一个像\"+1\"这么一个统一又优美的操作，使乘法也可以作用于变换呢？答案是，我们暂时找不到\n    * 所以，Translation我们需要使用这种方式来表示$$\\left ( \\begin{matrix} x'\\\\ y' \\end{matrix} \\right ) = \\left ( \\begin{matrix} a\u0026b\\\\ c\u0026d \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y \\end{matrix} \\right ) + \\left ( \\begin{matrix} t_x\\\\ t_y \\end{matrix} \\right )$$可这样表示后面会多出$$\\left ( \\begin{matrix} t_x\\\\ t_y \\end{matrix} \\right )$$使得偏偏平移变换与其它的变换**不同**，那有没有其它的方法呢？\n  * **齐次坐标**\n    * 以二维为例，我们新增一个**坐标分量**叫$w$，让其先等于$1$\n    * 则平移的矩阵可以表示为$$\\left ( \\begin{matrix} x'\\\\ y' \\\\1 \\end{matrix} \\right ) = \\left ( \\begin{matrix} 1\u00260\u0026t_x\\\\ 0\u00261\u0026t_y\\\\0\u00260\u00261 \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y\\\\1 \\end{matrix} \\right ) = \\left ( \\begin{matrix} x+t_x\\\\ y+t_y\\\\1 \\end{matrix} \\right )$$再来看一下用齐次坐标是否可以表示之前的那些变换,均匀缩放$$\\left ( \\begin{matrix} x'\\\\ y'\\\\1 \\end{matrix} \\right ) = \\left ( \\begin{matrix} s\u00260\u00260\\\\ 0\u0026s\u00260\\\\0\u00260\u00261 \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y\\\\1 \\end{matrix} \\right )$$以及旋转$$\\mathbf{R}_\\theta = \\left ( \\begin{matrix} cos\\theta \u0026 -sin\\theta\u00260 \\\\  sin\\theta \u0026 cos\\theta\u00260 \\\\0\u00260\u00261 \\end{matrix} \\right )$$都是可以的\n  * **变换复合**\n    * 如果还记得之前的变换复合，那么现在给你一个复合也会很容易就理解$$\\mathbf{T}_{(1,0)}\\mathbf{R}_{45^\\circ} = \\left ( \\begin{matrix} 1\u00260\u00261\\\\ 0\u00261\u00260\\\\0\u00260\u00261 \\end{matrix} \\right ) \\left ( \\begin{matrix} cos45^\\circ \u0026-sin45^\\circ \u00260\\\\ sin45^\\circ \u0026 cos45^\\circ \u00260\\\\0\u00260\u00261 \\end{matrix} \\right )$$3维下$$\\left ( \\begin{matrix} x'\\\\ y' \\\\z'\\\\1 \\end{matrix} \\right ) = \\left ( \\begin{matrix} 1\u00260\u00260\u0026t_x\\\\ 0\u00261\u00260\u0026t_y\\\\0\u00260\u00261\u0026t_z \\\\0\u00260\u00260\u00261 \\end{matrix} \\right ) \\left ( \\begin{matrix} x\\\\ y\\\\z\\\\1 \\end{matrix} \\right ) = \\left ( \\begin{matrix} x+t_x\\\\ y+t_y\\\\ z+t_z\\\\1 \\end{matrix} \\right )$$\n\n* **重心坐标**\n  * **插值Interpolation**\n    * 给一段距离，再选取这段距离上的一个区间并记刻度$0-1$，然后使用插值我们可以计算出这段距离上的每一处的值，当在中间时，就是$0.5$; 或者说我们将$0$刻度处设为\u003cspan style=\"color:red\"\u003e红色\u003c/span\u003e，$1$刻度处设为\u003cspan style=\"color:green\"\u003e绿色\u003c/span\u003e，同样使用插值我们可以计算出这段距离上每一处的颜色，使用颜色混合，当在中间时，红色和绿色的强度是一样的，我们知道可以混合出\u003cspan style=\"color:yellow\"\u003e黄色\u003c/span\u003e\n  * **重心坐标的引入**\n    * 模型可以使用许多三角形来表示\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/手绘模型三角形表示.11qpyej3om0g.webp\"\u003e\u003c/div\u003e刚才举例中的在一段距离上插值两个颜色应用到三角形上该如何表示呢？答案是使用**重心坐标**, 重心坐标就是在一个三角形内使用三个数值 ($\\alpha\\ \\beta\\ \\gamma$)，用这三个数值来表示这个三角形内每一个点的位置，并且需要满足这三个数值相加起来等于$1$\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/重心坐标介绍.4cy6cafle480.webp\" width=\"790\"\u003e\u003c/div\u003e用一种直观的感受，我们小时候应该玩过一种玩具，一个透明的塑料盖子里有一个迷宫，里面有一个小铁球，我们通过前后左右摆动来控制小铁球走出迷宫\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/重力球迷宫图片.1m4djnzlcrmo.webp\"\u003e\u003c/div\u003e将这个迷宫想象成三角形，当我们摇动时，这个小球就会前往这个三角形中不同的地方，是不是就是\u003cspan style=\"color:blue\"\u003e\"重心\"\u003c/span\u003e再往那个地方偏呢在，在数学中也是一样的道理。\u003cbr\u003e现在我们向左下移动，那么这个小球就会\"铛\"的一声，停靠在左下方\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/重心坐标示例.4ba7m720nk00.webp\" width=\"490\"\u003e\u003c/div\u003e那么就像所有的\"重心\"都落在了左下方这个$A$点上了，在数学上表示呢，就是$\\alpha$的数值为$1$,$\\beta$和$\\gamma$的值为$0$\n  * **如何计算这个坐标**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/重心坐标计算用图.j14mugbo4k0.webp\" width=\"790\"\u003e\u003c/div\u003e\n    * $P$点分别与三角形的三个顶点相连，我们可以得到三个小三角形，然后**通过分别计算这个三个小三角形的面积与整个三角形的面积的比值**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/重心坐标计算1.g6q54cfe988.webp\" width=\"790\"\u003e\u003c/div\u003e那么之前的那个例子通过计算就是小三角形$A_A$占据了整个三角形，与整个三角形的面积比值为$\\frac{1}{1}=1$,而小三角形$A_B$与$A_C$与整个三角形的面积比为$\\frac{0}{1}=0$,现在的问题就是我们如何计算这个**面积比值**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/重心坐标计算示例.2fikhcexbois.webp\" width=\"390\"\u003e\u003c/div\u003e\n    * 首先是三角形上的法线计算，使用叉乘$$\\mathbf{n}=(b-a)\\times (c-a)$$求得法线 (两个向量叉乘得第三个向量且垂直于这两个向量) 为什么要计算法线呢？因为计算法线与求面积有关,让我们继续往下看，在我们求得法线之后，我们就有三角形的面积为 $$area = \\frac{1}{2} ||n||$$这里为什么面积是$\\frac{1}{2}$倍的法线的模？抛开叉乘的几何意义，我们从代数意义去看叉乘\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/mathematics/叉乘与三角形面积.6bri9yhngtc0.webp\"\u003e\u003c/div\u003e其中$${\\displaystyle \\left\\|\\mathbf {a} \\times \\mathbf {b} \\right\\|=\\left\\|\\mathbf {a} \\right\\|\\left\\|\\mathbf {b} \\right\\|\\sin(\\theta)}$$是叉乘的模长计算公式，其中$a$向量的模也就是$a$的边长，$b$向量的模就是$b$的边长,根据三角形面积的计算公式$$\\Delta = \\frac{1}{2}ah$$我们发现，计算叉乘的过程正好是计算三角形面积的过程，只不过少除以了一个$2$，所以叉乘的模长的$\\frac{1}{2}$倍正好就是三角形的面积\n    * 计算其中两个小三角形的面积和整个三角形的面积，其中\n      * ①的面积为$$\\frac{1}{2}\\times ||(a-p)\\times (c-p)||$$②的面积为$$\\frac{1}{2}\\times ||(b-p)\\times (c-p)||$$整个三角形的面积为$$\\frac{1}{2}\\times ||(b-a)\\times (c-a)||$$则我们最终有$$ \\begin{array}{l} \\alpha =\\frac{①的面积}{整个三角形面积} \\\\ \\beta =\\frac{②的面积}{整个三角形面积} \\\\ \\gamma =1-\\alpha-\\beta \\end{array}$$\n    * 注：计算方法不唯一，还有一些其它的计算方法\n\n* 链接\n  * [1] 【线性代数】线性代数的本质 https://www.bilibili.com/video/BV18J411T7vS\n  * [2] 余弦定理_百度百科 https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86/957460\n  * [3] Games-101 https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\n  * [4] 两向量叉乘结果为什么垂直于原向量? https://www.zhihu.com/question/30118900\n  * [5] 2d matrix! https://ncase.me/matrix/\n  * [6] Triangle Area https://mathworld.wolfram.com/TriangleArea.html\n  * [7] Fundamentals of Computer Graphics\n\n## Day05-Graphics Basis\n\n\u003e 内容: 两条管道/流水线(空间变换、渲染管道)、相关概念(Local Space、World Space、View Space、Clip Space、NDC Space、Screen Space)、深度(线性深度、非线性深度)\n\n\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/life/enable-webgpu-on-googlechrome_dev.5l6548c2hg00.webp\" width=\"1200\"\u003e\u003c/div\u003e\n\n* **词汇表Glossary**\n  * Local Space 本地空间 \n  * World Space 世界空间\n  * View Space 观察空间\n  * Clip Space 裁切空间\n  * NDC Space 标准设备坐标空间\n  * Screen Space 屏幕空间\n  * Model Transformation 模型变换\n  * View Transformation 观察变换\n  * Perspective Transformation 透视变换\n  * Orthogonal Transformation 正交变换\n  * Viewport Transformation 视口变换\n  * Rasterization 光栅化\n\n* **两条管道/流水线**\n  * **渲染管道**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/WebGPU渲染管线.3vst1o5hmbs0.webp\" width=\"790\"\u003e\u003c/div\u003e\n    * \u003cspan style=\"color:blue\"\u003e顶点数据\u003c/span\u003e ----\u003e \u003cspan style=\"color:red\"\u003e顶点着色\u003c/span\u003e ----\u003e \u003cspan style=\"color:blue\"\u003e光栅化\u003c/span\u003e ----\u003e \u003cspan style=\"color:red\"\u003e片段着色\u003c/span\u003e ----\u003e \u003cspan style=\"color:blue\"\u003e屏幕显示\u003c/span\u003e\n  * **空间变换\"管道\"**\n    * \u003cspan style=\"color:blue\"\u003e本地空间\u003c/span\u003e ----\u003e (\u003cspan style=\"color:red\"\u003e模型变换\u003c/span\u003e) ----\u003e \u003cspan style=\"color:blue\"\u003e世界空间\u003c/span\u003e -\u003e (\u003cspan style=\"color:red\"\u003e观察变换\u003c/span\u003e) -\u003e \u003cspan style=\"color:blue\"\u003e观察空间\u003c/span\u003e ----\u003e (\u003cspan style=\"color:red\"\u003e投影变换\u003c/span\u003e) -\u003e \u003cspan style=\"color:blue\"\u003e裁切空间\u003c/span\u003e ----\u003e (\u003cspan style=\"color:purple\"\u003e除以w分量\u003c/span\u003e) ----\u003e \u003cspan style=\"color:blue\"\u003e规格化设备坐标空间\u003c/span\u003e ----\u003e (\u003cspan style=\"color:purple\"\u003e视口变换\u003c/span\u003e) -\u003e \u003cspan style=\"color:blue\"\u003e屏幕空间\u003c/span\u003e\n  * 补充：其中两个管道中的红色部分是我们参与其中的，就是那三个变换和那两个着色\n* **空间变换**\n  * 什么是空间变换？当我们想渲染一个物品到屏幕中，例如一个小盒子，从小盒子的角度出发，也就是**Local Space**，它看所有的物品都是相对于它来说的，例如小盒子的正前方有一个小球，是相对于小盒子来说它的前方有一个小球，但是对于小球来说，那么就不一定了，可能是小球的后方或者前后左右上下都有可能，那么就会出现小盒子说，不行，大家要以我为参考，小球会说，凭什么以你为参考呢？以我为参考不好吗？争执不下，那这样下去不行，所以最后我们规定某个指定的地方插一个小旗子:triangular_flag_on_post:，就指定这个地方在三维下就是$(0,0,0)$为坐标原点，所有的物品不管是小盒子还是小球或者其它什么物品，都必须以这个原点为相对参考，那么这样就清晰明了了，小盒子相对于原点在$(1,0,0)$处，等等，小球相对于原点在$(0,1,0)$处，这就是**World Space**\n  * 当我们观察一个物品时，以我们自己为原点，朝前方规定为朝$-z$方向看去，所以假设有一个小盒子在我们的左手边时，也就是$-x$方向，我们需要朝左转动头部90°，如果在上方的话，也就是$+y$方向，我们就需要朝上转动头部90°，但每次都要转动头部，好麻烦对吧？那么有没有其它的方法呢？还是假设这个小盒子在我们的左手边，如果我们想要观察它，则需要向左转动头部90°对吧，那么我就在想能不能不转动头部而是把这个小盒子拿到我的前方，也就是把这个小盒子相对我来说往右转动90°到我的正前方，仔细想想可以吗？是可以的，排除其它所有的事物，就想象只有我们自己和这个小盒子，**我们朝左转动去看这个小盒子和把这个小盒子朝右转动到我们面前再去看，最终的观察效果是一模一样的**！所以我们给在世界空间中的所有物品再做一个变换，能够让我们观察到，就像类似这个小盒子朝右转动一样，类似这样的变换之后的空间我们称作**View Space**\n  * 到了这里，我们知道物品的位置了，还知道了观察的方向，但是似乎还缺少一些东西，那就是如何去观察，就像我们的:eyes:眼睛一样，你是激光眼，透视眼，还是千里眼，还是写轮眼，眼睛不一样，看到的画面就会有不一样的效果，而我们的眼睛看到的呢就是最普通的透视效果，叫做**Perspective Transformation**，例如两条平行的铁轨\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/PerspectiveProjection.6ujk7r238gs0.webp\" width=\"190\"\u003e\u003c/div\u003e我们最终看到的画面是这种近大远小的，并且超出画面外的物品，也就是我们所看不到的都会被\"裁切\"掉，这种在指定了我们如何去**观察的方式**之后的我们称为**Clip Space**，当然还有另外一种常用的观察方式叫做**Orthogonal Transformation**，我们待会会讲到这两种的区别\n  * 所以对于任何物体，应用**Model Transformation**到**World Space**，然后应用**View Transformation**到**View Space**，再应用**Perspective Transformation**或者**Orthogonal Transformation**到**Clip Space**，再除以w分量到**NDC Space**，最后再应用**Viewport Transformation**到**Screen Space**，**Screen Space**就是最终的显示屏幕, 以上统称为**空间变换**\n* **渲染管道**\n  * 什么是渲染管道？想象一个汽车:car:生产车间，我们知道车间内部是有许多道工序的，但纵观整个车间来看，它就是一个很复杂的机器，我们给这个机器喂入一些原材料，例如金属，橡胶，设计图等等的东西，然后这个机器就会产出一辆汽车出来，它中间的工序我们可以先不用关心，最后这个机器会生产出汽车来，但只生产出汽车我们还不满意，希望可以在其中增加一些可以**定制化**的东西，例如在生产汽车的这个车间进行到了锻造这个工序的时候，我们可以自定义配置汽车的尺寸大小，然后到了喷漆这个工序的时候，我们可以自定义配置汽车的颜色，等等就像这样我们可以自己去配置的步骤，类比于渲染管道中对应的就是 锻造 -\u003e **顶点着色**，喷漆 -\u003e **片段着色**,而整个车间的生产工序就是类比于这个**渲染管道**本身，**顶点数据**就像我们生产这个汽车所喂入的原材料\n  * 补充：通常我们在自定义顶点着色的时候对这些原始的顶点数据应用**模型、观察和透视矩阵**\n\n* **相关概念**\n  * **World Space**\n    * 应用了Model Transform后，模型就从自身的Local Space转换到了World Space，通常是应用位移、旋转和缩放变换等\n  * **View Space**\n    * 之前我们介绍过，我们看向一个物体与把一个物体拿到我们面前是一样的，所以我们可以对世界空间中的物体应用一个View Transform从世界空间到观察者空间(或者称作相机空间)，通常是应用位移和旋转变换\n  * **Clip Space**\n    * **透视变换Perspective Transformation**\n      * 什么是透视变换？[图片](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/Perspective.4ihgtm58l9u0.webp) 透视变换是一个投影过程，其中透视变换就像将人的眼睛当做一个中心点，外部世界是一个大平面，在眼睛与这个平面之间形成一个椎体，然后将这个平面上的内容投射到眼睛内。\n      * 为什么变换之后的空间被称为裁切空间？裁切就是把不需要的部分去除掉，就是这幅图片中一样，投影平面在左侧\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/projection.1onr15yp0sv4.webp\" width=\"490\"\u003e\u003c/div\u003e而在投影中心另一侧的右侧的点我们是不需要的，假设这个点的坐标为$$(2,5,10)$$应用计算之后是$$x'=\\frac{2}{-10}=-0.2$$ $$y'=\\frac{5}{-10}=-0.5$$ $$z'=\\frac{10}{-10}=-1$$ 那么这个计算过程是如何进行的呢？根据相似三角形\u003ccenter\u003e\u003cimg style=\"border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/projection.5bbo6m777gs0.webp\"\u003e\u003cbr\u003e\u003cdiv style=\"color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\"\u003eFigure5.1 (从$P$投射到$P'$)\u003c/div\u003e\u003c/center\u003e我们有$$\\frac{BA=\\textcolor{blue}{z_{blue}}=1}{EA=\\textcolor{green}{z_{green}}=3}=\\frac{BC=y'}{EF=y}$$ $$y'=\\frac{y*\\textcolor{blue}{z_{blue}}}{\\textcolor{green}{z_{green}}}$$其中，由于我们的摄像机是看向$-z$方向的，所以$\\textcolor{green}{z_{green}}$在计算的时候前面要加$-$号，这就是式子$y'=\\frac{5}{-10}=-0.5$中$z$的值为$10$，计算是为$-10$\u003ccenter\u003e\u003cimg style=\"border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/透视校正插值.3imenutihfe0.webp\" width=\"490\"\u003e\u003cbr\u003e\u003cdiv style=\"color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\"\u003eLook at the projection from another aspect\u003c/div\u003e\u003c/center\u003e\n      * **步骤**\n        * 假设我们有一个矩阵 $$\\begin{aligned} \\left [ \\begin{matrix} 1\u00260\u00260\u00260\\\\0\u00261\u00260\u00260\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261 \\end{matrix}\\right ] \\end{aligned}$$\n        * 我们先让$z$坐标分量等于$-1$,这样计算后的$z'$就等于$1$,就可以满足如Figure5.1中的$$z'=z=1$$接下来，再调整$w$分量从$$[0,0,0,1] \\rightarrow [0,0,-1,0]$$这样一来,当除以$w$分量从齐次转三维中的点时，除以$w$分量相当于除以了$-z$分量，经过这样调整后我们有$$\\begin{aligned} \\left [ \\begin{matrix} 1\u00260\u00260\u00260\\\\0\u00261\u00260\u00260\\\\0\u00260\u0026-1\u0026-1\\\\0\u00260\u00260\u00260 \\end{matrix}\\right ] \\end{aligned}$$ 其计算过程正好是我们想要的 $$\\begin{aligned} \\left \\{ \\begin{matrix} x'=x*1+y*0+z*0+1*0\\ =x\\\\ y'=x*0+y*1+z*0+1*0\\ =y\\\\ z'=x*0+y*0+z*{-1}+1*0\\ ={-z}\\\\ w'=x*0+y*0+z*{-1}+1*0\\ ={-z} \\end{matrix}\\right. \\end{aligned}$$ $$\\begin{array}{ll} x' = \\dfrac{x'=x}{w'=-z},\\\\ y' = \\dfrac{y'=y}{w'=-z},\\\\ z' = \\dfrac{z'=-z}{w'=-z} = 1. \\end{array}$$ 其中$z'=\\frac{z}{w} = \\frac{-z}{-z} = 1$,　　$x'=\\frac{x}{w} = \\frac{x}{-z}$,　　$y'=\\frac{y}{w} = \\frac{y}{-z}$接下来我们就需要详细计算每个部分了\n        * [计算投影点的$x'$和$y'$坐标,将范围映射到[-1,1]](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/PerspProjectionDerivation.6edn0immf7o0.webp) $$\\left[\\begin{array}{cccc} { \\frac{2n}{ r-l } } \u0026 0 \u0026 ... \u0026 0 \\\\ 0 \u0026 { \\frac{2n}{ t-b } } \u0026 ... \u0026 0 \\\\ { \\frac{r + l}{ r-l } } \u0026 { \\frac{t + b}{ t-b } } \u0026 ... \u0026 {-1}\\\\ 0 \u0026 0 \u0026 ... \u0026 0\\\\ \\end{array}\\right]$$\n        * [将投影点的z坐标重新映射到范围[-1,1]](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/Remapping-the-z-coordinate-of-the-projected.2oof8otgmpu0.webp) \n          * (我们根据齐次转三维点时, $(x,y,z)$这三个分量都要除以$w$分量，我们有$$(x', y', z') = (x/w, y/w, z/w)$$其中$x$和$y$对$z$无影响)，则上一步骤中的矩阵可以设为$$\\left[\\begin{array}{cccc} { \\frac{2n}{ r-l } } \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 { \\frac{2n}{ t-b } } \u0026 0 \u0026 0 \\\\ { \\frac{r + l}{ r-l } } \u0026 { \\frac{t + b}{ t-b } } \u0026 \\textcolor{#FF0000}{A} \u0026 {-1}\\\\ 0 \u0026 0 \u0026 \\textcolor{#FF0000}{B} \u0026 0\\\\ \\end{array}\\right]$$ 其中\u003cspan style=\"color:red\"\u003eA\u003c/span\u003e和\u003cspan style=\"color:red\"\u003eB\u003c/span\u003e是我们要求的,则可以列出等式$$z' = \\dfrac{0 * x + 0 * y + A * z + B * w}{w = -z} \\rightarrow \\dfrac{A z + B}{w = -z}.$$ **注意这里的$w=1$是$(x,y,z,w=1)$中的$w$，而不是这个矩阵中的$w$分量**\u003cbr\u003e再根据我们已知$z$正好落在$near$近平面时应当等于$-1$，正好落在$far$远平面时应当等于$1$, 我们可以列出式子$$\\left\\{ \\begin{array}{ll} \\dfrac{(z=-n)A + B}{(-z=-(-n)=n)} = -1 \u0026\\text{ when } z = n\\\\ \\\\ \\dfrac{(z=-f)A + B}{(-z=-(-f)=f)} = 1 \u0026 \\text{ when } z = f \\end{array} \\right. $$ $$ \\rightarrow  \\left\\{ \\begin{array}{ll} {-nA + B} = -n \u0026 (1)\\\\  {-fA + B} = f \u0026 (2) \\end{array} \\right.$$ $$ A=-\\frac{f+n}{f-n} $$ $$ B=-\\frac{2fn}{f-n} $$ (也可以映射到[0,1]范围内)\n      * **资料**\n        * ①关于$P'_x = \\frac{P_x}{-P_z}$\n          * 链接: https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrices-what-you-need-to-know-first\n          * 为什么除以了$-z$呢？投影过程中的相似三角形中的比例关系\n        * ②关于透视矩阵中的齐次项的$-1$\n          * 链接: https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n          * 将原来透视矩阵中的$(0,0,0,1)$变为$(0,0,-1,0)$之后, 就说当我们用这个透视矩阵的$w$分量乘以一个齐次点$$(x,y,z,1)$$时，我们有$$x*0+y*0+z*-1+1*0 = -z$$也就是说，这个齐次点$w$的值经过矩阵计算之后从之前的$1$变为了$-z$,同时，齐次点$(x,y,z)$变为三维点时需要经过$(x/w, y/w, z/w)$，此时这样就有$$(x/w, y/w, z/w) \\Rightarrow (x/{-z}, y/{-z}, z/{-z})$$\n        * ③关于透视矩阵中的$z$项的$-1$\n          * 链接: https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n          * 因为摄像机是朝向$-z$方向的，所以摄像机前所有的点的$z$坐标都是负的，这就是为什么【资料①】中$$x' = \\frac{x}{-z}$$中的$z$前方带有负号\n      * **透视变换矩阵**$$\\begin{aligned} M_{persp} = \\left [ \\begin{matrix} \\frac{2n}{r-l} \u0026 0 \u0026 \\frac{l+r}{l-r} \u0026 0 \\\\ 0 \u0026 \\frac{2n}{t-b} \u0026 \\frac{b+t}{b-t} \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{f+n}{f-n} \u0026 \\frac{2nf}{n-f} \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{matrix}\\right ] \\end{aligned}$$ 或 $$\\begin{aligned} M_{persp} = \\left [ \\begin{matrix} \\frac{2n}{r-l} \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{2n}{t-b} \u0026 0 \u0026 0 \\\\ \\frac{r+l}{r-l} \u0026 \\frac{t+b}{t-b} \u0026 -\\frac{f+n}{f-n} \u0026 -1 \\\\ 0 \u0026 0 \u0026 -\\frac{2nf}{n-f} \u0026 0 \\end{matrix}\\right ] \\end{aligned}$$ \u003ccenter\u003e(注意其中两者之间的负号)\u003c/center\u003e\u003cbr\u003e则我们有$$[x', y', z', w'] = \\left [ \\begin{matrix} x\\\\y\\\\z\\\\w=1 \\end{matrix} \\right ] * M_{persp}$$ 其中$$w'=0*x + 0*y - 1*z + 0*1 = -z$$\n        * 计算并验证一下，假设$n=1，f=20$公式$$\\frac{-\\frac{f+n}{f-n} *z -\\frac{2fn}{f-n} }{-z}$$代入$n$和$f$并计算得$$\\frac{-\\frac{21}{19} * z - \\frac{40}{19}}{-z}$$其中$\\frac{-21}{19}=-1.1$和$\\frac{-40}{19}=-2.1$则得到结果\n        $$z=1 \\rightarrow \\frac{-1.1*1 -2.1}{-1} = 3.2$$ $$z=-1 \\rightarrow \\frac{-1.1*-1 -2.1}{1} = -1$$ $$z=-20 \\rightarrow \\frac{-1.1*-20 -2.1}{20} = 0.995$$ $$z=-21 \\rightarrow \\frac{-1.1*-21 -2.1}{21} = 1.1$$\n    * **正交变换Orthographic Transformation**\n      * 什么是正交变换？[图片](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/orthographic.24gyysktzse8.webp) 正交变换也是一个投影过程，这里则不像透视变换中那样是一个椎体了，而是一个方体，所以在正交变换中，近大远小这种情况则不存在，相反，你会看到所有的物体无论远近，在投影平面上都是有相仿的大小\n      * **步骤**\n        * 创建一个能够包含的下场景内所有物体的一个BoundingBox, $(l:left, r:right, t:top, b:bottom, f:front, b:back)$,然后将其映射到$(-1,-1,-1)$到$(1,1,1)$范围内；$x$坐标映射到$(l, r) \\Rightarrow (-1,1)$, $y$坐标映射到$(t,b) \\Rightarrow (1,-1)$，然后将内容投射到投影平面上\n      * **资料**\n        * ①正交矩阵计算过程\n          * https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\n      * **正交变换矩阵**$$\\begin{aligned} M_{ortho} \\left [ \\begin{matrix} \\frac{2}{r-l} \u0026 0 \u0026 0 \u0026 -\\frac{r+l}{r-l} \\\\ 0 \u0026 \\frac{2}{t-b} \u0026 0 \u0026 -\\frac{t+b}{t-b} \\\\ 0 \u0026 0 \u0026 \\frac{2}{n-f} \u0026 - \\frac{n+f}{n-f} \\\\ 0\u00260\u00260\u00261 \\end{matrix}\\right ] \\end{aligned}$$\n        * 计算并验证一下，首先场景中那个包含所有物体的那个BoundingBox的值我们需要知道，这里假设场景中有一个正方体尺寸为$1x1x1$,并且放置在世界中心原点处，那么它的左右上下边界值分别为$$(l:-0.5,　r:0.5,　t:0.5,　b:-0.5)$$然后再设置远近平面我们假设为$$(n:0.01,　f:100)$$则我们有$$left=-0.5,　right=0.5,　top=0.5,　bottom=-0.5,　\\\\near=0.01,　far=100$$根据这些我们最终可以计算出矩阵$$\\begin{aligned} M_{ortho} \\left [ \\begin{matrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 -0.02 \u0026 -1.002 \\\\ 0\u00260\u00260\u00261 \\end{matrix}\\right ] \\end{aligned}$$ 正方体其中一个顶点$(-0.5, -0.5, -0.5)$经过正交变换后有$$\\begin{aligned}  \\left [ \\begin{matrix} -0.5\u0026-0.5\u0026-0.5\u00261 \\end{matrix}\\right ] \\end{aligned} \\begin{aligned}  \\left [ \\begin{matrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 -0.02 \u0026 0 \\\\ 0\u00260\u0026-1.002\u00261 \\end{matrix}\\right ] \\end{aligned}\\begin{aligned}  \\left [ \\begin{matrix} -1\u0026-1\u0026-0.992\u00261 \\end{matrix}\\right ] \\end{aligned}$$ 再举一个例子$$\\begin{aligned}  \\left [ \\begin{matrix} -0.6\u0026-0.5\u0026-100.1\u00261 \\end{matrix}\\right ] \\end{aligned} \\begin{aligned}  \\left [ \\begin{matrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 -0.02 \u0026 0 \\\\ 0\u00260\u0026-1.002\u00261 \\end{matrix}\\right ] \\end{aligned}\\begin{aligned}  \\left [ \\begin{matrix} -1.2\u0026-1\u00261.002\u00261 \\end{matrix}\\right ] \\end{aligned}$$可以看到，后者超出了$(-1,1)$范围会被裁切掉\n    * **透视变换与正交变换**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/orthographic_perspective_view.6van0bm8j340.webp\" width=\"790\"\u003e\u003c/div\u003e [图片](https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/Perspective-and-Orthographic-Frustum.424xa80owoe.webp)\n      * 透视变换是将一个锥内我们所可以看到的事物，最终投射到一\"点\"处\n      * 正交变换是将一个方体内我们所可以看到的事物，最终投射到一\"面\"上\n  * **NDC Space**\n    * 从裁切空间转换到标准设备坐标空间，也就是把模型的$x、y、z$的范围重映射到$-1$到$1$范围内\n    * **在透视变换中和正交变换中**,我们已经这样做了，我们在构造矩阵的各个分量$xy$和$z$时已经将范围映射到$-1$到$1$之间了，(在正交矩阵中，最终除以$w$分量$(w=1)$得结果还是原先的数值)\n  * **Screen Space**\n    * 从NDC（三维）到我们的屏幕空间（二维），也就是真正要显示在屏幕上；首先NDC空间范围是$-1$到$1$，而屏幕空间表示像素范围对应的是$(0,0)$到$(w, h)$例如我们屏幕分辨率为$520\\times 520$那么就是$(520,520)$，也就是说我们需要从NDC的$(-1,-1)$到$(1,1)$映射到屏幕的$(0,0)$到$(520,520)$;假设有一点顶点为$(-0.5,-0.5,-0.5,1)$，是左下角的一个顶点 （也就是正交变换里我们计算并验证中的那个小盒子上的一个边界点）经过一个正交变换后是$(-1,1,-0.992,1)$，假设有一屏幕长为$520$，宽为$520$顶点$(-0.5,-0.5)$也就是NDC中的$(-1,-1)$会变换到屏幕空间中的$(0,0)$,同理如果是顶点$(0.5,0.5)$，NDC中的$(1,1)$会变成屏幕空间中的$(520, 520)$,我们假设另外一个顶点$(0.25,0.25)$,对应NDC中的$(0.5,0.5)$会变成屏幕空间中的$(390, 390)$\u003ccenter\u003e\u003cimg style=\"border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/ScreenSpace.6m3i63w9eqc0.webp\"\u003e\u003cbr\u003e\u003cdiv style=\"color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;\"\u003eFigure5.2\u003c/div\u003e\u003c/center\u003e根据这些我们可以得到我们的**视口变换矩阵**$$\\begin{aligned} \\left [ \\begin{matrix} \\frac{w}{2} \u0026 0 \u0026 0 \u0026 \\frac{w}{2} \\\\ 0 \u0026 \\frac{h}{2} \u0026 0 \u0026 \\frac{h}{2} \\\\ 0 \u0026 0 \u0026 \\frac{1}{2} \u0026 \\frac{1}{2} \\\\ 0\u00260\u00260\u00261 \\end{matrix}\\right ] \\end{aligned}$$ （矩阵中的$z$为$\\frac{1}{2}$是为保持$z$值不变） 来验证一下,假设我们的屏幕是$520\\times 520$的，则矩阵为$$\\begin{aligned} \\left [ \\begin{matrix} 260 \u0026 0 \u0026 0 \u0026 260 \\\\ 0 \u0026 260 \u0026 0 \u0026 260 \\\\ 0 \u0026 0 \u0026 0.5 \u0026 0.5 \\\\ 0\u00260\u00260\u00261 \\end{matrix}\\right ] \\end{aligned}$$ 顶点$(0.25,0.25)$，NDC中为$(0.5，0.5)$则$$\\begin{aligned} \\left [ \\begin{matrix} 0.5\u00260.5\u00261\u00261 \\end{matrix} \\right ] \\end{aligned} \\begin{aligned} \\left [ \\begin{matrix} 260 \u0026 0 \u0026 0 \u0026 260 \\\\ 0 \u0026 260 \u0026 0 \u0026 260 \\\\ 0 \u0026 0 \u0026 0.5 \u0026 0.5 \\\\ 0\u00260\u00260\u00261 \\end{matrix}\\right ] \\end{aligned} \\begin{aligned}  \\left [ \\begin{matrix} 390\u0026390\u00261\u00261 \\end{matrix}\\right ] \\end{aligned}$$ 顶点$(-0.5,-0.5)$，NDC中为$(-1，-1)$则$$\\begin{aligned} \\left [ \\begin{matrix} -1\u0026-1\u00261\u00261 \\end{matrix} \\right ] \\end{aligned} \\begin{aligned} \\left [ \\begin{matrix} 260 \u0026 0 \u0026 0 \u0026 260 \\\\ 0 \u0026 260 \u0026 0 \u0026 260 \\\\ 0 \u0026 0 \u0026 0.5 \u0026 0.5 \\\\ 0\u00260\u00260\u00261 \\end{matrix}\\right ] \\end{aligned} \\begin{aligned}  \\left [ \\begin{matrix} 0\u00260\u00261\u00261 \\end{matrix}\\right ] \\end{aligned}$$映射到屏幕坐标$(0,0)$像素点（也就是说最左下的那个小盒子的边界点正好映射到屏幕的左下角）\n    * 如果长宽是不一样的\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/ScreenSpace.7cnosi0vi480.webp\"\u003e\u003c/div\u003e长宽不一样我们依然可以处理，只不过要多一个概念$aspect$,$$aspect=\\frac{width}{height}$$它是一个比例\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/视口变换演示.19ypc5014qkg.webp\"\u003e\u003c/div\u003e 左上图是比例为$1:1$的情况下，如果我们改变了窗口大小，例如改为了$640\\times 480$，也就是比例为$1:1.3333$,如果我们此时什么都不做，则我们会得到左下的结果（仔细想想，为什么，是因为我们的视口变换矩阵，像素是一一对应的，**即使窗口大小变了，但映射关系并没有变**）所以我们如果才能得到右上的结果呢？ 很简单，在进行正交变换或者透视变换的时候将$x$方向也就是水平方向按照$aspect$比例收缩一些\n  * **Space Transformation**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/空间变换.3uujhna7v4o0.webp\"\u003e\u003c/div\u003e\n  * **深度**\n    * **线性深度**$$F_{depth}=\\frac{z-near}{far-near}$$\n      * 接近近平面的时值为$0$，远平面时为$1$，但我们通常不使用这个深度，因为我们的投影特性导致插值不是线性的(由于在投影平面上的相同步长随着三角形面与相机之间的距离增加而在三角形面上产生更大的步长-《Mathematics for 3D Game Programming and Computer Graphics-P107) (正交投影与透视投影的视锥不同，所以不存在透视投影中的近大远小效果，在这样的情况下，正交投影中的深度可以使用线性深度)\n    * **非线性深度**$$\\begin{aligned} F_{depth} = \\frac{\\frac{1}{z}-\\frac{1}{near}}{\\frac{1}{far}-\\frac{1}{near}} \\end{aligned}$$\n      * 为什么是非线性？\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/x分之1的函数图像.1wcc3u4z1sow.webp\"\u003e\u003c/div\u003e观察$\\frac{1}{x}$的图像我们可以知道，将$x$看做$z$，透视变换中我们也比上了$z$，所以最终总体的结果与这个函数的图像是类似的，通过观察我们可以看到$[0,0.5]$之间的区域占了总共了的$\\frac{4}{5}$还多，这也就意味着，**距离屏幕越近的模型将会获得越高的精度，反之，越远精度越低，而线性则是非常平均的，无论远近，精度一致**，这只是一个观察结果；在透视变换矩阵除以$w(w=-z)$分量进入NDC空间之前，它们是线性的，除以了$w$分量之后进入了NDC空间，就变为了非线性;此外除了深度，其它坐标也是非线性\n      * 函数图像链接: https://www.geogebra.org/m/zqnpanc7\n* **坐标转换**\n  * 到了这里我们已经可以从一个顶点一路经过各种变换到最终把它渲染在屏幕上，同样的，给你一个屏幕上的像素坐标且包含$z$值，你也同样可以从屏幕空间一路经过各种逆变换最终获取到最原始的顶点信息\n\n* **补充概念**\n  * **CanvasContext** - 我们最终呈现的画面它是由一系列的画布组合而成的，而这些画布配置是需要我们参与的，它们的名字叫做Attachments\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/FrameBufferAttachments.1tj7p0e7jkps.webp\" width=\"790\"\u003e\u003c/div\u003e\n  * **NDC Space** (Normalized device coordinate/规格化设备坐标) 归一化设备坐标或NDC空间是独立于屏幕的显示坐标系统; 它包含一个立方体，其中$x、y$和$z$组件的范围从$−1$到$1$。 \n  * **W Component**\n    * 可以通过增大$w$分量的值，是点朝向原点移动，减小$w$分量的值，可以使点朝向无穷点。(https://stackoverflow.com/questions/2422750/in-opengl-vertex-shaders-what-is-w-and-why-do-i-divide-by-it)\n    * 在到clip空间后，我们会根据$-w \\leq x,y,z \\leq w$来决定丢弃哪些模型,因为这是都是超出了屏幕之外的。例如$-w \\leq x \\leq w$是在$x$轴向上超出了，以此类推，这里为什么是与$w$的值比较与在NDC空间中为什么是除以$w$的值是归一化是如出一辙的。\n  * **FOV(Field-Of-View) \u0026 Aspect Ratio**\n    * **原理**\n      * 透视矩阵中我们使用$top、bottom、left、right、near、far$来定义，但通常我们不这样做，而是使用$fov、aspect\\ ratio、near、far$来定义，但他们本质上都是一样的，像人的眼睛也是有$fov$，叫做[视度](https://baike.baidu.com/item/%E4%BA%BA%E7%9C%BC%E8%A7%86%E5%BA%A6/5997035#)这么一说的,顾名思义，视度越大，我们看到的事物也就越多，例如$fov90$就比$fov60$看到的多，它是视点中心到视锥左侧与视点中心到视锥右侧所张开的角度，当然这样只能计算出左右侧的，还需要一个$aspect\\ ratio$(屏幕纵横比)来计算上下侧的。\n    * **计算**\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/FOV-image.5ljfnjoc8mc0.webp\"\u003e\u003c/div\u003e\n      * 根据三角函数$$\\begin{array}{l} \\tan( \\dfrac{ FOV } {2}) = \\dfrac{ opposite } { adjacent } = \\dfrac {BC}{AB} = \\dfrac{top}{near} \\\\ top = \\tan( \\dfrac{ FOV } {2}) * near \\\\ bottom = -top \\end{array}$$如果我们的$aspect\\ ratio$(宽高比)为$1$的话，则$$\\begin{array}{l} right = top\\\\ left = bottom = -top \\end{array}$$但通常我们的屏幕的宽高比都不是$1:1$的，如\u003cdiv align=center\u003e\u003cimg src=\"https://cdn.jsdelivr.net/gh/aaronmack/image-hosting@master/graphics/AspectRation.3dftg4ztsu00.webp\"\u003e\u003c/div\u003e图中右边所示，我们有公式$$\\frac{width}{height}=\\frac{right}{top}$$ $$\\frac{width}{height}=\\frac{left}{bottom}$$ (宽与左右对应，高与上下对应) 则我们有$$\\begin{array}{l} right = top * aspect\\ ratio \\\\ left = bottom * aspect\\ ratio \\end{array}$$其中$$aspect\\ ratio = \\frac{width}{height}$$ $$bottom = -top$$\n    day05-graphics/PerspectiveProjection.py\n\n* 链接\n  * [1] From 0 to glTF with WebGPU: The First Triangle - Updated https://www.willusher.io/graphics/2021/08/29/0-to-gltf-triangle\n  * [2] Raw WebGPU - Alain Galvan https://alain.xyz/blog/raw-webgpu\n  * [3] awesome-webgpu https://github.com/mikbry/awesome-webgpu/blob/master/readme.md\n  * [4] LearningWebGPU https://github.com/hjlld/LearningWebGPU\n  * [5] webgpu-samples https://austineng.github.io/webgpu-samples/\n  * [6] Chrome Platform Status- WebGPU https://chromestatus.com/feature/6213121689518080\n  * [7] Building a Basic Perspective Projection Matrix https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\n  * [8] The OpenGL Orthographic Projection Matrix https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\n  * [9] Orthographic Projection https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_04.pdf\n  * [10] 深度缓冲中的深度值计算及可视化 https://www.cnblogs.com/bzyzhang/p/12667859.html\n  * [11] 深度测试 https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/#_1\n  * [12] WebGL 3D Perspective https://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html\n","lastmodified":"2023-08-03T04:26:56.735063886Z","tags":[]}}